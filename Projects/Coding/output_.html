<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <link rel="stylesheet" href="../../te.css">
  <title>Current Setup</title>
</head>
<body>
<h2 id="module-of-methods">Module of methods</h2>
<ul>
<li>The current setup is a simple module of various methods.</li>
<li>Group of methods creates a list of stock pairs that should be tested
for whatever requirement and then executes the given test on them with
parallel processing across multiple data ranges. Example will be given
with a cointegration filter.</li>
</ul>
<h2 id="the-basic-methods">The Basic Methods</h2>
<h3 id="primary-variables">Primary Variables</h3>
<ul>
<li><code>stock_pair_list</code>: list of stock pairs which were chosen
at random, all possible combinations, or from whatever other filter
based elsewhere</li>
<li><code>shift_parameter</code>: an integer which uniquely
characterizes the data range being selected. It is essentially the
starting point of the data list, meaning how much the data has been
rolled forward from its initial starting point, which varies by
frequency of the data. It is measured units as that of the freq
<ul>
<li>Note that this is based on a custom data extraction method which is
very simple and merely is based on stored ‘close price’ from Yahoo
finance which will be explained later in more detail ### Methods</li>
</ul></li>
 <h3>Fundamental Methods</h3>
<li><code>cointegration_filter(one_pair):</code> executes the ADF test
for a single pair of stocks
<ul>
<li>`runner_multiple(): takes a list of stock pairs and list of shift
parameters and returns the list of pairs which pass the ADF test across
all given data ranges</li>
</ul></li>
<li><code>runner()</code>:
<ul>
<li><code>stock_pair_list,shift_parameter</code> -<code>&gt;</code>
<code>list_of_pairs_with_required_p_value,shift_parameter</code></li>
<li>takes a list of stock pairs as tuples and a shift parameter as an
integer and returns a list of stock pairs which pass the ADF test</li>
<li>handling the parallel processing<br />
</li>
</ul></li>
<li><code>runner_multiple()</code>:
<ul>
<li><code>stock_pair_list, list_of_shift_parameters -&gt; list_of_pairs_with_required_p_values_final</code>
<ul>
<li>handles the iterations over various data sets and returns all the
pairs of stocks which pass the ADF test in the give<br />
</li>
</ul></li>
</ul></li>
<li>The executed flow is
<code>runner_multiple() &gt; runner() &gt; cointegration_filter()</code></li>
<li>Note I use a custom overarching method <code>run</code>() which is
the same as main for all intents and purposes</li>
</ul>
<h2 id="code">Code</h2>
<pre><code>def cointegration_filter(cur_stock):  
  
    cur_pair=get_time_period(list(cur_stock[0:2]), custom_data=True, num_data_points=500,shift=cur_stock[2],freq=&#39;5m&#39;).dropna()  
    model = m.OLS(cur_pair[cur_stock[0]], m.add_constant(cur_pair[cur_stock[1]])).fit()  
  
    resudials = model.resid  
    adf_result = adfuller(resudials)  
    if adf_result[1] &lt; .0501:  
        return model.params.iloc[1]  
    else:  
        return -1000000  
  
def runner(stock_pair: pd.Series, shift_parameter: int,filter_func,args= None):  
  
    if args is not None:  
        p_list = [list(x) + [shift_parameter] + [float(y)] for x,y in zip(stock_pair.index,args)]  
    else:  
        p_list = [list(x) + [shift_parameter] for x in stock_pair.index]  
  
    with Pool(processes=15) as pool:  
        filter_results = pool.map(filter_func, p_list)  
    series_coint = pd.Series(index=stock_pair.index,data= filter_results)  
  
    filt = series_coint[[x for x in series_coint.index if -1000000 not in  series_coint[x]]]  
  
    return pd.Series(data=[[x] for x in filt],index=filt.index)  
  
def runner_multiple(stock_pair_list: pd.Series, shift_parameter_list: list,filter_func,args=None):  
    

    if all([len(x) == 1 for x in stock_pair_list]):  
        args = pd.DataFrame([x[:len(x)-1] for x in args],index=stock_pair_list.index)  
        args = [list(args.iloc[:,x]) for x in range(len(args.columns))]  
  
    stock_pairs_final = runner(stock_pair_list,shift_parameter_list[0],filter_func,args[0])  
  
    if len(shift_parameter_list) == 1:  
        return (stock_pairs_final + stock_pair_list).dropna()  
    return runner_multiple((stock_pairs_final + stock_pair_list).dropna(),shift_parameter_list[1:],  
                           filter_func,args[1:])
                           
def run():

    #Example pair of stock pairs and shift parameters
    stock_pair_list = pd.Series([(&#39;AAPL&#39;,&#39;AMAC&#39;),(&#39;FICO&#39;,&#39;GE&#39;)])
    shift_parameter_list = [0,50]
    
    runner_multiple(stock_pair_list,shift_parameter_list,cointegration_filter)</code></pre>
</body>
</html>
