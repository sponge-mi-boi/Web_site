<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <link rel="stylesheet" href="../../te.css">
  <title>Current Setup</title>
</head>
<body>
<h2 id="module-of-methods">Module of methods</h2>
<ul>
<li>The current setup is a simple module of various methods.</li>
<li>Group of methods creates a list of stock pairs that should be tested
for whatever requirement and then executes the given test on them with
parallel processing across multiple data ranges. Example will be given
with a cointegration filter.</li>
</ul>
<h2 id="the-basic-methods">The Basic Methods</h2>
<h3 id="primary-variables">Primary Variables</h3>
<ul>
<li><code>stock_pair_list</code>: list of stock pairs which were chosen
at random, all possible combinations, or from whatever other filter
based elsewhere</li>
<li><code>shift_parameter</code>: an integer which uniquely
characterizes the data range being selected. It is essentially the
starting point of the data list, meaning how much the data has been
rolled forward from its initial starting point, which varies by
frequency of the data. It is measured units as that of the freq
<ul>
<li>Note that this is based on a custom data extraction method which is
very simple and merely is based on stored ‘close price’ from Yahoo
finance which will be explained later in more detail</li>
</ul></li>
    <h2>Methods</h2>
 <h3>Fundamental Methods</h3>
<li><code>cointegration_filter(one_pair):</code> executes the ADF test
for a single pair of stocks
<ul>
<li>runner_multiple(): takes a list of stock pairs and list of shift
parameters and returns the list of pairs which pass the ADF test across
all given data ranges</li>
</ul></li>
<li><code>runner()</code>:
<ul>
<li><code>stock_pair_list,shift_parameter</code> -<code>&gt;</code>
<code>list_of_pairs_with_required_p_value,shift_parameter</code></li>
<li>takes a list of stock pairs as tuples and a shift parameter as an
integer and returns a list of stock pairs which pass the ADF test</li>
<li>handling the parallel processing<br />
</li>
</ul></li>
<li><code>runner_multiple()</code>:
<ul>
<li><code>stock_pair_list, list_of_shift_parameters -&gt; list_of_pairs_with_required_p_values_final</code>
<ul>
<li>handles the iterations over various data sets and returns all the
pairs of stocks which pass the ADF test in the give<br />
</li>
</ul></li>
</ul></li>
<li>The executed flow is
<code>runner_multiple() &gt; runner() &gt; cointegration_filter()</code></li>
<li>Note I use a custom overarching method <code>run</code>() which is
the same as main for all intents and purposes</li>
</ul>
<h2 id="code">Code</h2>

<pre><code><span class='c1'> # This is the first filter that can be used in terms of determining if a stock, or in this situation, a pair of stocks, is cointegrated, from the ADF test with a p value requirement of .05 
</span>
def cointegration_filter(cur_stock):  
  
    cur_pair=get_time_period(list(cur_stock[0:2]), custom_data=True, num_data_points=500,shift=cur_stock[2],freq='5m').dropna()  
    model = m.OLS(cur_pair[cur_stock[0]], m.add_constant(cur_pair[cur_stock[1]])).fit()  
  
    resudials = model.resid  
    adf_result = adfuller(resudials)  
    if adf_result[1] < .0501:  
        return model.params.iloc[1]  
    else:  
        return -1000000  
  
<span class='c1'> # This is the executer of the parallel processing where the joblib class, specifically pool, is used. 15 concurrent processes are being run in this situation.(Note there is essentially a splitting based on the time period being run on by the data, which is characterized by the shift parameter
</span>
<span class='c1'> ## args is an optional argument which stores time period related information. An example would be the beta values which can be used in the beta based weighing of stocks when executing a portfolio backtest upon a given set of time period
</span>
def runner(stock_pair: pd.Series, shift_parameter: int,filter_func,args= None):  
  
    if args is not None:  
	    p_list = [list(x) + [shift_parameter] + [float(y)] for x,y in zip(stock_pair.index,args)]  
	else:  
        p_list = [list(x) + [shift_parameter] for x in stock_pair.index]  
  
    with Pool(processes=15) as pool:  
        filter_results = pool.map(filter_func, p_list)  
    series_coint = pd.Series(index=stock_pair.index,data= filter_results)  
  
    filt = series_coint[[x for x in series_coint.index if -1000000 not in  series_coint[x]]]  
  
    return pd.Series(data=[[x] for x in filt],index=filt.index)  

<span class='c1'> # This handles the iteration of each of the stock pairs by time period.
</span>
def runner_multiple(stock_pair_list: pd.Series, shift_parameter_list: list,filter_func,args=None):  
	

    if all([len(x) == 1 for x in stock_pair_list]):  
        args = pd.DataFrame([x[:len(x)-1] for x in args],index=stock_pair_list.index)  
        args = [list(args.iloc[:,x]) for x in range(len(args.columns))]  
  
    stock_pairs_final = runner(stock_pair_list,shift_parameter_list[0],filter_func,args[0])  
  
    if len(shift_parameter_list) == 1:  
        return (stock_pairs_final + stock_pair_list).dropna()  
    return runner_multiple((stock_pairs_final + stock_pair_list).dropna(),shift_parameter_list[1:],  
                           filter_func,args[1:])
                           
def run():

	<span class='c1'> #Example pair of stock pairs and shift parameters</span>
	stock_pair_list = pd.Series([('AAPL','AMAC'),('FICO','GE')])
	shift_parameter_list = [0,50]
	
	runner_multiple(stock_pair_list,shift_parameter_list,cointegration_filter)

</code></pre>
</body>
</html>
